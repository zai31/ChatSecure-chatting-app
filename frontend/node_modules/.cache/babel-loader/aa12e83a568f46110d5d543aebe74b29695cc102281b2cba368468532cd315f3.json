{"ast":null,"code":"import Keycloak from 'keycloak-js';\nwindow.addEventListener(\"message\", event => {\n  console.log(\" Message received from iframe:\", event.data);\n});\n\n// Get the current URL as a string\nconst getCurrentUrl = () => {\n  try {\n    const url = new URL(window.location.href);\n    // Remove any query parameters that might interfere with Keycloak\n    url.search = '';\n    return url.toString();\n  } catch (error) {\n    console.error('Failed to parse current URL:', error);\n    // Fallback to using origin with path\n    const origin = window.location.origin;\n    const path = window.location.pathname;\n    return `${origin}${path}`;\n  }\n};\n\n// Ensure URL is a string\nconst ensureStringUrl = url => {\n  if (typeof url === 'string') {\n    return url;\n  }\n  if (url instanceof URL) {\n    return url.toString();\n  }\n  if (typeof url === 'object' && url.origin) {\n    return `${url.origin}${url.pathname || ''}`;\n  }\n  console.warn('Invalid URL format:', url);\n  return window.location.origin;\n};\nconst keycloakConfig = {\n  url: 'http://localhost:9090',\n  realm: 'whatsapp-clone',\n  clientId: 'whatsapp-clone-app',\n  redirectUri: window.location.origin + '/',\n  onLoad: 'login-required',\n  silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html',\n  pkceMethod: 'S256',\n  checkLoginIframe: false,\n  enableLogging: true,\n  flow: 'standard',\n  responseMode: 'fragment',\n  cors: true,\n  corsOrigins: ['http://localhost:4200']\n};\nlet keycloakInstance = null;\nlet initializationState = {\n  initialized: false,\n  inProgress: false,\n  error: null\n};\nconst clearExistingTokens = () => {\n  try {\n    localStorage.removeItem('kc-callback');\n    localStorage.removeItem('kc-login-redirect');\n\n    // Clear any Keycloak-related items\n    Object.keys(localStorage).forEach(key => {\n      if (key.startsWith('kc-') || key.includes('keycloak')) {\n        localStorage.removeItem(key);\n      }\n    });\n\n    // Clear session storage items too\n    Object.keys(sessionStorage).forEach(key => {\n      if (key.startsWith('kc-') || key.includes('keycloak')) {\n        sessionStorage.removeItem(key);\n      }\n    });\n    console.log('Cleared existing Keycloak tokens');\n  } catch (e) {\n    console.error('Failed to clear tokens:', e);\n  }\n};\nconst handleInitError = (error, config) => {\n  const errorDetails = {\n    message: 'Unknown error during Keycloak initialization',\n    details: 'No error object was provided',\n    config: config\n  };\n  if (!error) {\n    errorDetails.details = 'Initialization failed without error object';\n    return errorDetails;\n  }\n  try {\n    // Try to get error details from the error object\n    errorDetails.message = error.message || error.toString() || 'Unknown error';\n    errorDetails.details = error.stack || error.toString();\n    errorDetails.code = error.code;\n  } catch (e) {\n    errorDetails.details = 'Error object could not be processed';\n  }\n\n  // Add configuration details\n  errorDetails.config = {\n    url: ensureStringUrl(config.url),\n    realm: config.realm,\n    clientId: config.clientId,\n    redirectUri: ensureStringUrl(config.redirectUri),\n    cors: config.cors,\n    corsOrigins: config.corsOrigins\n  };\n  return errorDetails;\n};\nconst checkKeycloakServer = async () => {\n  try {\n    const response = await fetch(`${keycloakConfig.url}/realms/${keycloakConfig.realm}/.well-known/openid-configuration`, {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json'\n      },\n      mode: 'cors'\n    });\n    if (response.ok) {\n      console.log('Keycloak server is accessible');\n      return true;\n    } else {\n      console.error('Keycloak server returned error:', response.status);\n      return false;\n    }\n  } catch (error) {\n    console.error('Failed to connect to Keycloak server:', error);\n    return false;\n  }\n};\nconst initKeycloak = async (forceRefresh = false) => {\n  // If already initialized and not forcing refresh, return instance\n  if (keycloakInstance && initializationState.initialized && !forceRefresh) {\n    return keycloakInstance;\n  }\n\n  // If initialization is in progress, wait for it\n  if (initializationState.inProgress) {\n    console.warn('Keycloak initialization already in progress');\n\n    // Wait for initialization to complete or fail\n    return new Promise((resolve, reject) => {\n      const checkInterval = setInterval(() => {\n        if (!initializationState.inProgress) {\n          clearInterval(checkInterval);\n          if (initializationState.initialized) {\n            resolve(keycloakInstance);\n          } else {\n            reject(initializationState.error);\n          }\n        }\n      }, 100);\n    });\n  }\n  initializationState.inProgress = true;\n\n  // If forcing refresh, clear existing tokens\n  if (forceRefresh) {\n    clearExistingTokens();\n  }\n  try {\n    // Check if Keycloak server is accessible\n    const serverAvailable = await checkKeycloakServer();\n    if (!serverAvailable) {\n      throw new Error('Keycloak server is not accessible');\n    }\n\n    // Create new Keycloak instance\n    keycloakInstance = new Keycloak(keycloakConfig);\n\n    // Add event listeners for debugging\n    keycloakInstance.onAuthSuccess = () => console.log('Auth success');\n    keycloakInstance.onAuthError = error => console.error('Auth error:', error);\n    keycloakInstance.onAuthRefreshSuccess = () => console.log('Auth refresh success');\n    keycloakInstance.onAuthRefreshError = () => console.log('Auth refresh error');\n    keycloakInstance.onAuthLogout = () => console.log('Auth logout');\n    keycloakInstance.onTokenExpired = () => console.log('Token expired');\n\n    // Initialize with explicit options\n    const authenticated = await keycloakInstance.init({\n      onLoad: keycloakConfig.onLoad,\n      checkLoginIframe: keycloakConfig.checkLoginIframe,\n      pkceMethod: keycloakConfig.pkceMethod,\n      enableLogging: true,\n      responseMode: 'fragment',\n      flow: keycloakConfig.flow,\n      redirectUri: keycloakConfig.redirectUri\n    });\n    console.log('Keycloak initialized successfully, authenticated:', authenticated);\n    initializationState.initialized = true;\n    initializationState.error = null;\n    return keycloakInstance;\n  } catch (error) {\n    console.error('Keycloak initialization failed:', error);\n    const processedError = handleInitError(error, keycloakConfig);\n    initializationState.error = processedError;\n\n    // If we got a specific error about tokens, try clearing them and retrying once\n    if (!forceRefresh && (error.toString().includes('token') || !error.toString())) {\n      console.log('Token-related error detected, retrying with cleared tokens...');\n      initializationState.inProgress = false;\n      return initKeycloak(true); // Retry with force refresh\n    }\n    throw processedError;\n  } finally {\n    initializationState.inProgress = false;\n  }\n};\nconst getKeycloak = () => {\n  if (!initializationState.initialized) {\n    throw new Error('Keycloak has not been initialized yet');\n  }\n  return keycloakInstance;\n};\nconst getInitializationState = () => initializationState;\nconst logout = async () => {\n  if (keycloakInstance && initializationState.initialized) {\n    try {\n      await keycloakInstance.logout({\n        redirectUri: window.location.origin\n      });\n      clearExistingTokens();\n      initializationState.initialized = false;\n    } catch (error) {\n      console.error('Logout failed:', error);\n      // Force clear tokens even if logout fails\n      clearExistingTokens();\n      initializationState.initialized = false;\n    }\n  }\n};\nexport { initKeycloak, getKeycloak, getInitializationState, logout };\nexport default keycloakInstance;","map":{"version":3,"names":["Keycloak","window","addEventListener","event","console","log","data","getCurrentUrl","url","URL","location","href","search","toString","error","origin","path","pathname","ensureStringUrl","warn","keycloakConfig","realm","clientId","redirectUri","onLoad","silentCheckSsoRedirectUri","pkceMethod","checkLoginIframe","enableLogging","flow","responseMode","cors","corsOrigins","keycloakInstance","initializationState","initialized","inProgress","clearExistingTokens","localStorage","removeItem","Object","keys","forEach","key","startsWith","includes","sessionStorage","e","handleInitError","config","errorDetails","message","details","stack","code","checkKeycloakServer","response","fetch","method","headers","mode","ok","status","initKeycloak","forceRefresh","Promise","resolve","reject","checkInterval","setInterval","clearInterval","serverAvailable","Error","onAuthSuccess","onAuthError","onAuthRefreshSuccess","onAuthRefreshError","onAuthLogout","onTokenExpired","authenticated","init","processedError","getKeycloak","getInitializationState","logout"],"sources":["C:/Intel/whats-clone-backEnd/frontend/src/keycloak.js"],"sourcesContent":["import Keycloak from 'keycloak-js';\n\nwindow.addEventListener(\"message\", (event) => {\n    console.log(\" Message received from iframe:\", event.data);\n});\n\n// Get the current URL as a string\nconst getCurrentUrl = () => {\n    try {\n        const url = new URL(window.location.href);\n        // Remove any query parameters that might interfere with Keycloak\n        url.search = '';\n        return url.toString();\n    } catch (error) {\n        console.error('Failed to parse current URL:', error);\n        // Fallback to using origin with path\n        const origin = window.location.origin;\n        const path = window.location.pathname;\n        return `${origin}${path}`;\n    }\n};\n\n\n// Ensure URL is a string\nconst ensureStringUrl = (url) => {\n    if (typeof url === 'string') {\n        return url;\n    }\n    if (url instanceof URL) {\n        return url.toString();\n    }\n    if (typeof url === 'object' && url.origin) {\n        return `${url.origin}${url.pathname || ''}`;\n    }\n    console.warn('Invalid URL format:', url);\n    return window.location.origin;\n};\n\nconst keycloakConfig = {\n    url: 'http://localhost:9090',\n    realm: 'whatsapp-clone',\n    clientId: 'whatsapp-clone-app',\n    redirectUri: window.location.origin + '/',\n    onLoad: 'login-required', \n    silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html',\n    pkceMethod: 'S256',\n    checkLoginIframe: false,\n    enableLogging: true, \n    flow: 'standard',\n    responseMode: 'fragment', \n    cors: true,\n    corsOrigins: ['http://localhost:4200']\n};\n\nlet keycloakInstance = null;\nlet initializationState = {\n    initialized: false,\n    inProgress: false,\n    error: null\n};\n\nconst clearExistingTokens = () => {\n    try {\n        localStorage.removeItem('kc-callback');\n        localStorage.removeItem('kc-login-redirect');\n        \n        // Clear any Keycloak-related items\n        Object.keys(localStorage).forEach(key => {\n            if (key.startsWith('kc-') || key.includes('keycloak')) {\n                localStorage.removeItem(key);\n            }\n        });\n        \n        // Clear session storage items too\n        Object.keys(sessionStorage).forEach(key => {\n            if (key.startsWith('kc-') || key.includes('keycloak')) {\n                sessionStorage.removeItem(key);\n            }\n        });\n        \n        console.log('Cleared existing Keycloak tokens');\n    } catch (e) {\n        console.error('Failed to clear tokens:', e);\n    }\n};\n\nconst handleInitError = (error, config) => {\n    const errorDetails = {\n        message: 'Unknown error during Keycloak initialization',\n        details: 'No error object was provided',\n        config: config\n    };\n\n    if (!error) {\n        errorDetails.details = 'Initialization failed without error object';\n        return errorDetails;\n    }\n\n    try {\n        // Try to get error details from the error object\n        errorDetails.message = error.message || error.toString() || 'Unknown error';\n        errorDetails.details = error.stack || error.toString();\n        errorDetails.code = error.code;\n    } catch (e) {\n        errorDetails.details = 'Error object could not be processed';\n    }\n\n    // Add configuration details\n    errorDetails.config = {\n        url: ensureStringUrl(config.url),\n        realm: config.realm,\n        clientId: config.clientId,\n        redirectUri: ensureStringUrl(config.redirectUri),\n        cors: config.cors,\n        corsOrigins: config.corsOrigins\n    };\n\n    return errorDetails;\n};\n\nconst checkKeycloakServer = async () => {\n    try {\n        const response = await fetch(`${keycloakConfig.url}/realms/${keycloakConfig.realm}/.well-known/openid-configuration`, {\n            method: 'GET',\n            headers: {\n                'Accept': 'application/json',\n            },\n            mode: 'cors'\n        });\n        \n        if (response.ok) {\n            console.log('Keycloak server is accessible');\n            return true;\n        } else {\n            console.error('Keycloak server returned error:', response.status);\n            return false;\n        }\n    } catch (error) {\n        console.error('Failed to connect to Keycloak server:', error);\n        return false;\n    }\n};\n\nconst initKeycloak = async (forceRefresh = false) => {\n    // If already initialized and not forcing refresh, return instance\n    if (keycloakInstance && initializationState.initialized && !forceRefresh) {\n        return keycloakInstance;\n    }\n    \n    // If initialization is in progress, wait for it\n    if (initializationState.inProgress) {\n        console.warn('Keycloak initialization already in progress');\n        \n        // Wait for initialization to complete or fail\n        return new Promise((resolve, reject) => {\n            const checkInterval = setInterval(() => {\n                if (!initializationState.inProgress) {\n                    clearInterval(checkInterval);\n                    if (initializationState.initialized) {\n                        resolve(keycloakInstance);\n                    } else {\n                        reject(initializationState.error);\n                    }\n                }\n            }, 100);\n        });\n    }\n    \n    initializationState.inProgress = true;\n    \n    // If forcing refresh, clear existing tokens\n    if (forceRefresh) {\n        clearExistingTokens();\n    }\n    \n    try {\n        // Check if Keycloak server is accessible\n        const serverAvailable = await checkKeycloakServer();\n        if (!serverAvailable) {\n            throw new Error('Keycloak server is not accessible');\n        }\n        \n        // Create new Keycloak instance\n        keycloakInstance = new Keycloak(keycloakConfig);\n        \n        // Add event listeners for debugging\n        keycloakInstance.onAuthSuccess = () => console.log('Auth success');\n        keycloakInstance.onAuthError = (error) => console.error('Auth error:', error);\n        keycloakInstance.onAuthRefreshSuccess = () => console.log('Auth refresh success');\n        keycloakInstance.onAuthRefreshError = () => console.log('Auth refresh error');\n        keycloakInstance.onAuthLogout = () => console.log('Auth logout');\n        keycloakInstance.onTokenExpired = () => console.log('Token expired');\n        \n        // Initialize with explicit options\n        const authenticated = await keycloakInstance.init({\n            onLoad: keycloakConfig.onLoad,\n            checkLoginIframe: keycloakConfig.checkLoginIframe,\n            pkceMethod: keycloakConfig.pkceMethod,\n            enableLogging: true,\n            responseMode: 'fragment',\n            flow: keycloakConfig.flow,\n            redirectUri: keycloakConfig.redirectUri\n        });\n        \n        console.log('Keycloak initialized successfully, authenticated:', authenticated);\n        \n        initializationState.initialized = true;\n        initializationState.error = null;\n        return keycloakInstance;\n    } catch (error) {\n        console.error('Keycloak initialization failed:', error);\n        const processedError = handleInitError(error, keycloakConfig);\n        initializationState.error = processedError;\n        \n        // If we got a specific error about tokens, try clearing them and retrying once\n        if (!forceRefresh && (error.toString().includes('token') || !error.toString())) {\n            console.log('Token-related error detected, retrying with cleared tokens...');\n            initializationState.inProgress = false;\n            return initKeycloak(true); // Retry with force refresh\n        }\n        \n        throw processedError;\n    } finally {\n        initializationState.inProgress = false;\n    }\n};\n\nconst getKeycloak = () => {\n    if (!initializationState.initialized) {\n        throw new Error('Keycloak has not been initialized yet');\n    }\n    return keycloakInstance;\n};\n\nconst getInitializationState = () => initializationState;\n\nconst logout = async () => {\n    if (keycloakInstance && initializationState.initialized) {\n        try {\n            await keycloakInstance.logout({redirectUri: window.location.origin});\n            clearExistingTokens();\n            initializationState.initialized = false;\n        } catch (error) {\n            console.error('Logout failed:', error);\n            // Force clear tokens even if logout fails\n            clearExistingTokens();\n            initializationState.initialized = false;\n        }\n    }\n};\n\nexport { initKeycloak, getKeycloak, getInitializationState, logout };\nexport default keycloakInstance;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}