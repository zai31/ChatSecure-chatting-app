{"ast":null,"code":"import Keycloak from 'keycloak-js';\nwindow.addEventListener(\"message\", event => {\n  console.log(\" Message received from iframe:\", event.data);\n});\n\n// Get the current URL as a string\nconst getCurrentUrl = () => {\n  try {\n    const url = new URL(window.location.href);\n    // Remove any query parameters that might interfere with Keycloak\n    url.search = '';\n    return url.toString();\n  } catch (error) {\n    console.error('Failed to parse current URL:', error);\n    // Fallback to using origin with path\n    const origin = window.location.origin;\n    const path = window.location.pathname;\n    return `${origin}${path}`;\n  }\n};\n\n// Ensure URL is a string\nconst ensureStringUrl = url => {\n  if (typeof url === 'string') {\n    return url;\n  }\n  if (url instanceof URL) {\n    return url.toString();\n  }\n  if (typeof url === 'object' && url.origin) {\n    return `${url.origin}${url.pathname || ''}`;\n  }\n  console.warn('Invalid URL format:', url);\n  return window.location.origin;\n};\nconst keycloakConfig = {\n  url: 'http://localhost:9090',\n  realm: 'whatsapp-clone',\n  clientId: 'whatsapp-clone-app',\n  redirectUri: window.location.origin + '/',\n  onLoad: 'login-required',\n  silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html',\n  pkceMethod: 'S256',\n  checkLoginIframe: false,\n  enableLogging: true,\n  flow: 'standard',\n  responseMode: 'fragment',\n  cors: true,\n  corsOrigins: ['http://localhost:4200']\n};\nlet keycloakInstance = null;\nlet initializationState = {\n  initialized: false,\n  inProgress: false,\n  error: null\n};\nconst clearExistingTokens = () => {\n  try {\n    localStorage.removeItem('kc-callback');\n    localStorage.removeItem('kc-login-redirect');\n\n    // Clear any Keycloak-related items\n    Object.keys(localStorage).forEach(key => {\n      if (key.startsWith('kc-') || key.includes('keycloak')) {\n        localStorage.removeItem(key);\n      }\n    });\n\n    // Clear session storage items too\n    Object.keys(sessionStorage).forEach(key => {\n      if (key.startsWith('kc-') || key.includes('keycloak')) {\n        sessionStorage.removeItem(key);\n      }\n    });\n    console.log('Cleared existing Keycloak tokens');\n  } catch (e) {\n    console.error('Failed to clear tokens:', e);\n  }\n};\nconst handleInitError = (error, config) => {\n  const errorDetails = {\n    message: 'Unknown error during Keycloak initialization',\n    details: 'No error object was provided',\n    config: {}\n  };\n\n  // Safely copy config values\n  if (config) {\n    errorDetails.config = {\n      url: config.url ? ensureStringUrl(config.url) : 'Not available',\n      realm: config.realm || 'Not available',\n      clientId: config.clientId || 'Not available',\n      redirectUri: config.redirectUri ? ensureStringUrl(config.redirectUri) : 'Not available',\n      cors: !!config.cors,\n      corsOrigins: Array.isArray(config.corsOrigins) ? config.corsOrigins : ['Not configured']\n    };\n  }\n  if (!error) {\n    errorDetails.details = 'Initialization failed without error object';\n    return errorDetails;\n  }\n  try {\n    // Try to get error details from the error object\n    errorDetails.message = error.message || error.toString() || 'Unknown error';\n    errorDetails.details = error.stack || error.toString();\n    errorDetails.code = error.code;\n  } catch (e) {\n    errorDetails.details = 'Error object could not be processed';\n  }\n  return errorDetails;\n};\nconst checkKeycloakServer = async () => {\n  try {\n    console.log(`Attempting to connect to Keycloak server at ${keycloakConfig.url}`);\n\n    // Set a timeout for the fetch request\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout\n\n    const response = await fetch(`${keycloakConfig.url}/realms/${keycloakConfig.realm}/.well-known/openid-configuration`, {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json'\n      },\n      mode: 'cors',\n      signal: controller.signal\n    });\n    clearTimeout(timeoutId);\n    if (response.ok) {\n      console.log('Keycloak server is accessible');\n      return true;\n    } else {\n      console.error(`Keycloak server returned error: ${response.status} - ${response.statusText}`);\n      return false;\n    }\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Keycloak server connection timed out after 5 seconds');\n    } else {\n      console.error('Failed to connect to Keycloak server:', error);\n    }\n\n    // Check if the server is running on a different port\n    try {\n      console.log('Attempting to check if Keycloak is running on a different port...');\n      // Try to fetch just the domain without a specific path\n      const domainResponse = await fetch(new URL(keycloakConfig.url).origin, {\n        method: 'GET',\n        mode: 'no-cors' // This will allow us to at least detect if something is running there\n      });\n      console.log('Something is running on the server, but the Keycloak realm might not be accessible');\n    } catch (domainError) {\n      console.error('Server appears to be completely offline:', domainError);\n    }\n    return false;\n  }\n};\nconst initKeycloak = async (forceRefresh = false) => {\n  // If already initialized and not forcing refresh, return instance\n  if (keycloakInstance && initializationState.initialized && !forceRefresh) {\n    return keycloakInstance;\n  }\n\n  // If initialization is in progress, wait for it\n  if (initializationState.inProgress) {\n    console.warn('Keycloak initialization already in progress');\n\n    // Wait for initialization to complete or fail\n    return new Promise((resolve, reject) => {\n      const checkInterval = setInterval(() => {\n        if (!initializationState.inProgress) {\n          clearInterval(checkInterval);\n          if (initializationState.initialized) {\n            resolve(keycloakInstance);\n          } else {\n            reject(initializationState.error);\n          }\n        }\n      }, 100);\n    });\n  }\n  initializationState.inProgress = true;\n\n  // If forcing refresh, clear existing tokens\n  if (forceRefresh) {\n    clearExistingTokens();\n  }\n  try {\n    // Check if Keycloak server is accessible\n    let serverAvailable = false;\n    try {\n      serverAvailable = await checkKeycloakServer();\n    } catch (e) {\n      console.error('Error checking Keycloak server:', e);\n    }\n    if (!serverAvailable) {\n      console.error('Keycloak server is not accessible');\n      const serverError = new Error('Keycloak server is not accessible');\n      serverError.serverUnavailable = true;\n      serverError.suggestions = ['Ensure Keycloak server is running on port 9090', 'Check network connectivity and firewall settings', 'Verify the realm \"whatsapp-clone\" exists', 'Confirm the client \"whatsapp-clone-app\" is properly configured'];\n      throw serverError;\n    }\n\n    // Create new Keycloak instance\n    keycloakInstance = new Keycloak(keycloakConfig);\n\n    // Add event listeners for debugging\n    keycloakInstance.onAuthSuccess = () => console.log('Auth success');\n    keycloakInstance.onAuthError = error => console.error('Auth error:', error);\n    keycloakInstance.onAuthRefreshSuccess = () => console.log('Auth refresh success');\n    keycloakInstance.onAuthRefreshError = () => console.log('Auth refresh error');\n    keycloakInstance.onAuthLogout = () => console.log('Auth logout');\n    keycloakInstance.onTokenExpired = () => console.log('Token expired');\n\n    // Initialize with explicit options\n    const authenticated = await keycloakInstance.init({\n      onLoad: keycloakConfig.onLoad,\n      checkLoginIframe: keycloakConfig.checkLoginIframe,\n      pkceMethod: keycloakConfig.pkceMethod,\n      enableLogging: true,\n      responseMode: 'fragment',\n      flow: keycloakConfig.flow,\n      redirectUri: keycloakConfig.redirectUri\n    });\n    console.log('Keycloak initialized successfully, authenticated:', authenticated);\n    initializationState.initialized = true;\n    initializationState.error = null;\n    return keycloakInstance;\n  } catch (error) {\n    console.error('Keycloak initialization failed:', error);\n    const processedError = handleInitError(error, keycloakConfig);\n\n    // Add any additional properties from the original error\n    if (error) {\n      processedError.serverUnavailable = error.serverUnavailable;\n      processedError.suggestions = error.suggestions;\n    }\n    initializationState.error = processedError;\n\n    // If we got a specific error about tokens, try clearing them and retrying once\n    if (!forceRefresh && error && (String(error).includes('token') || !String(error))) {\n      console.log('Token-related error detected, retrying with cleared tokens...');\n      initializationState.inProgress = false;\n      return initKeycloak(true); // Retry with force refresh\n    }\n    throw processedError;\n  } finally {\n    initializationState.inProgress = false;\n  }\n};\nconst getKeycloak = () => {\n  if (!initializationState.initialized) {\n    throw new Error('Keycloak has not been initialized yet');\n  }\n  return keycloakInstance;\n};\nconst getInitializationState = () => initializationState;\nconst logout = async () => {\n  if (keycloakInstance && initializationState.initialized) {\n    try {\n      await keycloakInstance.logout({\n        redirectUri: window.location.origin\n      });\n      clearExistingTokens();\n      initializationState.initialized = false;\n    } catch (error) {\n      console.error('Logout failed:', error);\n      // Force clear tokens even if logout fails\n      clearExistingTokens();\n      initializationState.initialized = false;\n    }\n  }\n};\nexport { initKeycloak, getKeycloak, getInitializationState, logout };\nexport default keycloakInstance;","map":{"version":3,"names":["Keycloak","window","addEventListener","event","console","log","data","getCurrentUrl","url","URL","location","href","search","toString","error","origin","path","pathname","ensureStringUrl","warn","keycloakConfig","realm","clientId","redirectUri","onLoad","silentCheckSsoRedirectUri","pkceMethod","checkLoginIframe","enableLogging","flow","responseMode","cors","corsOrigins","keycloakInstance","initializationState","initialized","inProgress","clearExistingTokens","localStorage","removeItem","Object","keys","forEach","key","startsWith","includes","sessionStorage","e","handleInitError","config","errorDetails","message","details","Array","isArray","stack","code","checkKeycloakServer","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","method","headers","mode","signal","clearTimeout","ok","status","statusText","name","domainResponse","domainError","initKeycloak","forceRefresh","Promise","resolve","reject","checkInterval","setInterval","clearInterval","serverAvailable","serverError","Error","serverUnavailable","suggestions","onAuthSuccess","onAuthError","onAuthRefreshSuccess","onAuthRefreshError","onAuthLogout","onTokenExpired","authenticated","init","processedError","String","getKeycloak","getInitializationState","logout"],"sources":["C:/Intel/whats-clone-backEnd/frontend/src/keycloak.js"],"sourcesContent":["import Keycloak from 'keycloak-js';\n\nwindow.addEventListener(\"message\", (event) => {\n    console.log(\" Message received from iframe:\", event.data);\n});\n\n// Get the current URL as a string\nconst getCurrentUrl = () => {\n    try {\n        const url = new URL(window.location.href);\n        // Remove any query parameters that might interfere with Keycloak\n        url.search = '';\n        return url.toString();\n    } catch (error) {\n        console.error('Failed to parse current URL:', error);\n        // Fallback to using origin with path\n        const origin = window.location.origin;\n        const path = window.location.pathname;\n        return `${origin}${path}`;\n    }\n};\n\n\n// Ensure URL is a string\nconst ensureStringUrl = (url) => {\n    if (typeof url === 'string') {\n        return url;\n    }\n    if (url instanceof URL) {\n        return url.toString();\n    }\n    if (typeof url === 'object' && url.origin) {\n        return `${url.origin}${url.pathname || ''}`;\n    }\n    console.warn('Invalid URL format:', url);\n    return window.location.origin;\n};\n\nconst keycloakConfig = {\n    url: 'http://localhost:9090',\n    realm: 'whatsapp-clone',\n    clientId: 'whatsapp-clone-app',\n    redirectUri: window.location.origin + '/',\n    onLoad: 'login-required', \n    silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html',\n    pkceMethod: 'S256',\n    checkLoginIframe: false,\n    enableLogging: true, \n    flow: 'standard',\n    responseMode: 'fragment', \n    cors: true,\n    corsOrigins: ['http://localhost:4200']\n};\n\nlet keycloakInstance = null;\nlet initializationState = {\n    initialized: false,\n    inProgress: false,\n    error: null\n};\n\nconst clearExistingTokens = () => {\n    try {\n        localStorage.removeItem('kc-callback');\n        localStorage.removeItem('kc-login-redirect');\n        \n        // Clear any Keycloak-related items\n        Object.keys(localStorage).forEach(key => {\n            if (key.startsWith('kc-') || key.includes('keycloak')) {\n                localStorage.removeItem(key);\n            }\n        });\n        \n        // Clear session storage items too\n        Object.keys(sessionStorage).forEach(key => {\n            if (key.startsWith('kc-') || key.includes('keycloak')) {\n                sessionStorage.removeItem(key);\n            }\n        });\n        \n        console.log('Cleared existing Keycloak tokens');\n    } catch (e) {\n        console.error('Failed to clear tokens:', e);\n    }\n};\n\nconst handleInitError = (error, config) => {\n    const errorDetails = {\n        message: 'Unknown error during Keycloak initialization',\n        details: 'No error object was provided',\n        config: {}\n    };\n\n    // Safely copy config values\n    if (config) {\n        errorDetails.config = {\n            url: config.url ? ensureStringUrl(config.url) : 'Not available',\n            realm: config.realm || 'Not available',\n            clientId: config.clientId || 'Not available',\n            redirectUri: config.redirectUri ? ensureStringUrl(config.redirectUri) : 'Not available',\n            cors: !!config.cors,\n            corsOrigins: Array.isArray(config.corsOrigins) ? config.corsOrigins : ['Not configured']\n        };\n    }\n\n    if (!error) {\n        errorDetails.details = 'Initialization failed without error object';\n        return errorDetails;\n    }\n\n    try {\n        // Try to get error details from the error object\n        errorDetails.message = error.message || error.toString() || 'Unknown error';\n        errorDetails.details = error.stack || error.toString();\n        errorDetails.code = error.code;\n    } catch (e) {\n        errorDetails.details = 'Error object could not be processed';\n    }\n\n    return errorDetails;\n};\n\nconst checkKeycloakServer = async () => {\n    try {\n        console.log(`Attempting to connect to Keycloak server at ${keycloakConfig.url}`);\n        \n        // Set a timeout for the fetch request\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout\n        \n        const response = await fetch(`${keycloakConfig.url}/realms/${keycloakConfig.realm}/.well-known/openid-configuration`, {\n            method: 'GET',\n            headers: {\n                'Accept': 'application/json',\n            },\n            mode: 'cors',\n            signal: controller.signal\n        });\n        \n        clearTimeout(timeoutId);\n        \n        if (response.ok) {\n            console.log('Keycloak server is accessible');\n            return true;\n        } else {\n            console.error(`Keycloak server returned error: ${response.status} - ${response.statusText}`);\n            return false;\n        }\n    } catch (error) {\n        if (error.name === 'AbortError') {\n            console.error('Keycloak server connection timed out after 5 seconds');\n        } else {\n            console.error('Failed to connect to Keycloak server:', error);\n        }\n        \n        // Check if the server is running on a different port\n        try {\n            console.log('Attempting to check if Keycloak is running on a different port...');\n            // Try to fetch just the domain without a specific path\n            const domainResponse = await fetch(new URL(keycloakConfig.url).origin, {\n                method: 'GET',\n                mode: 'no-cors' // This will allow us to at least detect if something is running there\n            });\n            \n            console.log('Something is running on the server, but the Keycloak realm might not be accessible');\n        } catch (domainError) {\n            console.error('Server appears to be completely offline:', domainError);\n        }\n        \n        return false;\n    }\n};\n\nconst initKeycloak = async (forceRefresh = false) => {\n    // If already initialized and not forcing refresh, return instance\n    if (keycloakInstance && initializationState.initialized && !forceRefresh) {\n        return keycloakInstance;\n    }\n    \n    // If initialization is in progress, wait for it\n    if (initializationState.inProgress) {\n        console.warn('Keycloak initialization already in progress');\n        \n        // Wait for initialization to complete or fail\n        return new Promise((resolve, reject) => {\n            const checkInterval = setInterval(() => {\n                if (!initializationState.inProgress) {\n                    clearInterval(checkInterval);\n                    if (initializationState.initialized) {\n                        resolve(keycloakInstance);\n                    } else {\n                        reject(initializationState.error);\n                    }\n                }\n            }, 100);\n        });\n    }\n    \n    initializationState.inProgress = true;\n    \n    // If forcing refresh, clear existing tokens\n    if (forceRefresh) {\n        clearExistingTokens();\n    }\n    \n    try {\n        // Check if Keycloak server is accessible\n        let serverAvailable = false;\n        try {\n            serverAvailable = await checkKeycloakServer();\n        } catch (e) {\n            console.error('Error checking Keycloak server:', e);\n        }\n        \n        if (!serverAvailable) {\n            console.error('Keycloak server is not accessible');\n            const serverError = new Error('Keycloak server is not accessible');\n            serverError.serverUnavailable = true;\n            serverError.suggestions = [\n                'Ensure Keycloak server is running on port 9090',\n                'Check network connectivity and firewall settings',\n                'Verify the realm \"whatsapp-clone\" exists',\n                'Confirm the client \"whatsapp-clone-app\" is properly configured'\n            ];\n            throw serverError;\n        }\n        \n        // Create new Keycloak instance\n        keycloakInstance = new Keycloak(keycloakConfig);\n        \n        // Add event listeners for debugging\n        keycloakInstance.onAuthSuccess = () => console.log('Auth success');\n        keycloakInstance.onAuthError = (error) => console.error('Auth error:', error);\n        keycloakInstance.onAuthRefreshSuccess = () => console.log('Auth refresh success');\n        keycloakInstance.onAuthRefreshError = () => console.log('Auth refresh error');\n        keycloakInstance.onAuthLogout = () => console.log('Auth logout');\n        keycloakInstance.onTokenExpired = () => console.log('Token expired');\n        \n        // Initialize with explicit options\n        const authenticated = await keycloakInstance.init({\n            onLoad: keycloakConfig.onLoad,\n            checkLoginIframe: keycloakConfig.checkLoginIframe,\n            pkceMethod: keycloakConfig.pkceMethod,\n            enableLogging: true,\n            responseMode: 'fragment',\n            flow: keycloakConfig.flow,\n            redirectUri: keycloakConfig.redirectUri\n        });\n        \n        console.log('Keycloak initialized successfully, authenticated:', authenticated);\n        \n        initializationState.initialized = true;\n        initializationState.error = null;\n        return keycloakInstance;\n    } catch (error) {\n        console.error('Keycloak initialization failed:', error);\n        const processedError = handleInitError(error, keycloakConfig);\n        \n        // Add any additional properties from the original error\n        if (error) {\n            processedError.serverUnavailable = error.serverUnavailable;\n            processedError.suggestions = error.suggestions;\n        }\n        \n        initializationState.error = processedError;\n        \n        // If we got a specific error about tokens, try clearing them and retrying once\n        if (!forceRefresh && error && (String(error).includes('token') || !String(error))) {\n            console.log('Token-related error detected, retrying with cleared tokens...');\n            initializationState.inProgress = false;\n            return initKeycloak(true); // Retry with force refresh\n        }\n        \n        throw processedError;\n    } finally {\n        initializationState.inProgress = false;\n    }\n};\n\nconst getKeycloak = () => {\n    if (!initializationState.initialized) {\n        throw new Error('Keycloak has not been initialized yet');\n    }\n    return keycloakInstance;\n};\n\nconst getInitializationState = () => initializationState;\n\nconst logout = async () => {\n    if (keycloakInstance && initializationState.initialized) {\n        try {\n            await keycloakInstance.logout({redirectUri: window.location.origin});\n            clearExistingTokens();\n            initializationState.initialized = false;\n        } catch (error) {\n            console.error('Logout failed:', error);\n            // Force clear tokens even if logout fails\n            clearExistingTokens();\n            initializationState.initialized = false;\n        }\n    }\n};\n\nexport { initKeycloak, getKeycloak, getInitializationState, logout };\nexport default keycloakInstance;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}